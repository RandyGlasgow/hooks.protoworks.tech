# Async Callbacks

Handle asynchronous operations with event handlers and await event completion across multiple listeners.

## Overview

The event bus supports async callbacks, allowing you to perform asynchronous operations like API calls, database updates, or file operations. You can also await all handlers to complete before continuing.

## Basic Async Handler

Event handlers can be async functions:

```tsx
"use client";

import { useMonitorEvent } from "@protoworx/react-ripple-effect";

function DataSaver() {
  useMonitorEvent({
    "save-data": async (data) => {
      // Async operations are fully supported
      await saveToDatabase(data);
      await updateCache(data);
      console.log("Data saved!");
    },
  });

  return <div>Data saver...</div>;
}
```

## Awaiting Event Completion

When triggering an event, you can await all handlers to complete:

```tsx
"use client";

import { useTriggerEvent } from "@protoworx/react-ripple-effect";

function SaveButton() {
  const trigger = useTriggerEvent();

  const handleSave = async () => {
    // Wait for all handlers to complete
    await trigger("save-data", { userId: 123, name: "Alice" });
    console.log("All save handlers completed!");
  };

  return <button onClick={handleSave}>Save</button>;
}
```

## Complete Example

Here's a complete example showing async handlers and awaiting completion:

```tsx
"use client";

import {
  EventDriver,
  EventProvider,
  useMonitorEvent,
  useTriggerEvent,
} from "@protoworx/react-ripple-effect";
import { useState } from "react";

const client = new EventDriver();

export default function App() {
  return (
    <EventProvider client={client}>
      <SaveButton />
      <DatabaseSaver />
      <CacheUpdater />
      <NotificationSender />
      <StatusDisplay />
    </EventProvider>
  );
}

function SaveButton() {
  const trigger = useTriggerEvent();
  const [saving, setSaving] = useState(false);

  const handleSave = async () => {
    setSaving(true);
    try {
      // Wait for all handlers to complete
      await trigger("save-data", {
        userId: 123,
        name: "Alice",
        email: "alice@example.com",
      });
      console.log("All save operations completed!");
    } catch (error) {
      console.error("Save failed:", error);
    } finally {
      setSaving(false);
    }
  };

  return (
    <button onClick={handleSave} disabled={saving}>
      {saving ? "Saving..." : "Save User"}
    </button>
  );
}

function DatabaseSaver() {
  const [lastSaved, setLastSaved] = useState<string | null>(null);

  useMonitorEvent({
    "save-data": async (data) => {
      // Simulate database save
      await new Promise((resolve) => setTimeout(resolve, 500));
      console.log("Saved to database:", data);
      setLastSaved(new Date().toLocaleTimeString());
    },
  });

  return (
    <div>
      <h3>Database</h3>
      {lastSaved && <p>Last saved: {lastSaved}</p>}
    </div>
  );
}

function CacheUpdater() {
  const [cacheUpdated, setCacheUpdated] = useState<string | null>(null);

  useMonitorEvent({
    "save-data": async (data) => {
      // Simulate cache update
      await new Promise((resolve) => setTimeout(resolve, 300));
      console.log("Cache updated:", data);
      setCacheUpdated(new Date().toLocaleTimeString());
    },
  });

  return (
    <div>
      <h3>Cache</h3>
      {cacheUpdated && <p>Last updated: {cacheUpdated}</p>}
    </div>
  );
}

function NotificationSender() {
  const [notificationSent, setNotificationSent] = useState<string | null>(null);

  useMonitorEvent({
    "save-data": async (data) => {
      // Simulate sending notification
      await new Promise((resolve) => setTimeout(resolve, 200));
      console.log("Notification sent:", data);
      setNotificationSent(new Date().toLocaleTimeString());
    },
  });

  return (
    <div>
      <h3>Notifications</h3>
      {notificationSent && <p>Last sent: {notificationSent}</p>}
    </div>
  );
}

function StatusDisplay() {
  return (
    <div className="mt-4 p-4 bg-muted rounded">
      <p>All handlers run in parallel and complete independently.</p>
      <p>The trigger waits for all handlers to finish before continuing.</p>
    </div>
  );
}
```

## Error Handling

Async handlers can throw errors, which propagate to the trigger:

```tsx
"use client";

import { useMonitorEvent, useTriggerEvent } from "@protoworx/react-ripple-effect";

function ErrorHandler() {
  useMonitorEvent({
    "save-data": async (data) => {
      if (!data.userId) {
        throw new Error("User ID is required");
      }
      await saveToDatabase(data);
    },
  });

  return null;
}

function SaveButton() {
  const trigger = useTriggerEvent();

  const handleSave = async () => {
    try {
      await trigger("save-data", { userId: 123 });
    } catch (error) {
      // Handle errors from any handler
      console.error("Save failed:", error);
    }
  };

  return <button onClick={handleSave}>Save</button>;
}
```

## Parallel Execution

Multiple async handlers execute in parallel, not sequentially:

```tsx
"use client";

import { useMonitorEvent } from "@protoworx/react-ripple-effect";

function ParallelHandlers() {
  useMonitorEvent({
    "process-data": async (data) => {
      // All three handlers start at the same time
      const [result1, result2, result3] = await Promise.all([
        processInHandler1(data),
        processInHandler2(data),
        processInHandler3(data),
      ]);
      // This handler waits for all three to complete
      combineResults(result1, result2, result3);
    },
  });

  return null;
}
```

## Combining with Debounce/Throttle

You can combine async handlers with debounce or throttle:

```tsx
"use client";

import { useMonitorEvent } from "@protoworx/react-ripple-effect";

function SearchHandler() {
  useMonitorEvent({
    "search:input": {
      callback: async (query: string) => {
        // Debounced async API call
        const results = await fetchSearchResults(query);
        displayResults(results);
      },
      debounce: 300,
    },
  });

  return null;
}
```

## Best Practices

1. **Error Handling**: Always wrap async handlers in try-catch when needed
2. **Timeout Protection**: Consider adding timeouts for long-running operations
3. **Loading States**: Use loading states to indicate async operations in progress
4. **Parallel vs Sequential**: Remember handlers run in parallel, not sequentially

## Related Examples

- [Basic Usage](/docs/examples/basic-usage) - Learn the fundamentals
- [Debounce & Throttle](/docs/examples/debounce-throttle) - Combine with async operations
- [Real-World Examples](/docs/examples/real-world) - See async patterns in practice

