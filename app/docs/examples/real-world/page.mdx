import { ExampleSection } from "@/components/docs/example-section";
import { AnalyticsDemo } from "@/components/docs/demos/analytics-demo";
import { FormValidationDemo } from "@/components/docs/demos/form-validation-demo";
import { ShoppingCartDemo } from "@/components/docs/demos/shopping-cart-demo";
import { MultiStepWorkflowDemo } from "@/components/docs/demos/multi-step-workflow-demo";

# Real-World Examples

Complete workflows and component implementations demonstrating practical use cases for the event bus.

## Overview

These examples show how to use the event bus in real applications with complete component implementations, event flows, and workflow patterns. Each example includes a live interactive demo - click the "Code" tab to see the implementation.

<ExampleSection
  title="Analytics Tracking"
  description="Track user actions across your application without coupling components to analytics code."
  eventFlow={`User Action → trigger("analytics.track") → Analytics Service (monitors)
                                         → Debug Logger (monitors)
                                         → A/B Test Tracker (monitors)`}
  demo={<AnalyticsDemo />}
  code={`
 "use client";

import {
  EventDriver,
  EventProvider,
  useMonitorEvent,
  useTriggerEvent,
} from "@protoworx/react-ripple-effect";

type AppEvents = {
"analytics.track": {
event: string;
properties?: Record<string, any>;
};
};

const client = new EventDriver();

export default function App() {
  return (
    <EventProvider client={client}>
      <Navigation />
      <ProductCard />
      <AnalyticsService />
    </EventProvider>
  );
}

// Navigation component
function Navigation() {
const trigger = useTriggerEvent<AppEvents>();

const handleNavClick = (page: string) => {
trigger("analytics.track", {
event: "navigation_click",
properties: { page },
});
};

return (

<nav>
  <button onClick={() => handleNavClick("home")}>Home</button>
  <button onClick={() => handleNavClick("products")}>Products</button>
  <button onClick={() => handleNavClick("about")}>About</button>
</nav>
); }

// Product card component
function ProductCard() {
const trigger = useTriggerEvent<AppEvents>();

const handleView = (productId: string) => {
trigger("analytics.track", {
event: "product_view",
properties: { productId },
});
};

const handleAddToCart = (productId: string) => {
trigger("analytics.track", {
event: "add_to_cart",
properties: { productId },
});
};

return (

<div>
  <h3>Product Name</h3>
  <button onClick={() => handleView("123")}>View</button>
  <button onClick={() => handleAddToCart("123")}>Add to Cart</button>
</div>
); }

// Analytics service that processes all tracking events
function AnalyticsService() {
useMonitorEvent<AppEvents>({
"analytics.track": async (data) => {
// Send to analytics service (e.g., Google Analytics, Mixpanel)
await fetch("/api/analytics", {
method: "POST",
body: JSON.stringify(data),
});
},
});

return null;
}`}
/>

<ExampleSection
  title="Form Validation"
  description="Decouple form validation logic from form components using the event bus."
  eventFlow={`Form Input → trigger("form:validate") → Validation Service (monitors)
                                      → Error Display (monitors)
                                      → Analytics (monitors)`}
  demo={<FormValidationDemo />}
  code={`"use client";

import {
  EventDriver,
  EventProvider,
  useMonitorEvent,
  useTriggerEvent,
} from "@protoworx/react-ripple-effect";
import { useState } from "react";

type AppEvents = {
"form:validate": {
field: string;
value: string;
};
"form:error": {
field: string;
error: string;
};
"form:success": {
field: string;
};
};

const client = new EventDriver();

export default function App() {
  return (
    <EventProvider client={client}>
      <ContactForm />
      <ValidationService />
      <ErrorDisplay />
    </EventProvider>
  );
}

// Form component
function ContactForm() {
const trigger = useTriggerEvent<AppEvents>();
const [formData, setFormData] = useState({
email: "",
name: "",
message: "",
});

const handleChange = (field: string, value: string) => {
setFormData((prev) => ({ ...prev, [field]: value }));
trigger("form:validate", { field, value });
};

return (

<form>
  <div>
    <label>Name</label>
    <input
      value={formData.name}
      onChange={(e) => handleChange("name", e.target.value)}
    />
  </div>
  <div>
    <label>Email</label>
    <input
      type="email"
      value={formData.email}
      onChange={(e) => handleChange("email", e.target.value)}
    />
  </div>
  <div>
    <label>Message</label>
    <textarea
      value={formData.message}
      onChange={(e) => handleChange("message", e.target.value)}
    />
  </div>
</form>
); }

// Validation service
function ValidationService() {
const trigger = useTriggerEvent<AppEvents>();

useMonitorEvent<AppEvents>({
"form:validate": {
callback: (data) => {
const { field, value } = data;

        if (field === "email") {
          const emailRegex = /^[^\s@]+@[^\s@]+\\.[^\s@]+$/;
          if (!emailRegex.test(value)) {
            trigger("form:error", {
              field,
              error: "Invalid email format",
            });
          } else {
            trigger("form:success", { field });
          }
        } else if (field === "name") {
          if (value.length < 2) {
            trigger("form:error", {
              field,
              error: "Name must be at least 2 characters",
            });
          } else {
            trigger("form:success", { field });
          }
        } else if (field === "message") {
          if (value.length < 10) {
            trigger("form:error", {
              field,
              error: "Message must be at least 10 characters",
            });
          } else {
            trigger("form:success", { field });
          }
        }
      },
      debounce: 300, // Wait for user to stop typing
    },

});

return null;
}

// Error display component
function ErrorDisplay() {
const [errors, setErrors] = useState<Record<string, string>>({});

useMonitorEvent<AppEvents>({
"form:error": (data) => {
setErrors((prev) => ({
...prev,
[data.field]: data.error,
}));
},
"form:success": (data) => {
setErrors((prev) => {
const next = { ...prev };
delete next[data.field];
return next;
});
},
});

return (

<div>
  {Object.entries(errors).map(([field, error]) => (
    <div key={field} className="text-red-500">
      {field}: {error}
    </div>
  ))}
</div>
); }`} />

<ExampleSection
  title="Shopping Cart Updates"
  description="Update multiple parts of the UI when cart changes, including UI updates, persistence, and notifications."
  eventFlow={`Add to Cart → trigger("cart:updated") → Cart UI (monitors)
                                     → LocalStorage (monitors)
                                     → Toast Notification (monitors)
                                     → Analytics (monitors)`}
  demo={<ShoppingCartDemo />}
  code={`"use client";

import {
  EventDriver,
  EventProvider,
  useMonitorEvent,
  useTriggerEvent,
} from "@protoworx/react-ripple-effect";
import { useState } from "react";

type CartItem = {
id: string;
name: string;
price: number;
quantity: number;
};

type AppEvents = {
"cart:updated": {
item: CartItem;
action: "add" | "remove" | "update";
};
"toast.show": {
message: string;
type?: "info" | "success" | "error";
};
};

const client = new EventDriver();

export default function App() {
  return (
    <EventProvider client={client}>
      <ProductList />
      <CartSidebar />
      <CartPersistence />
      <CartNotifications />
    </EventProvider>
  );
}

// Product list component
function ProductList() {
const trigger = useTriggerEvent<AppEvents>();

const products = [
{ id: "1", name: "Product 1", price: 29.99 },
{ id: "2", name: "Product 2", price: 39.99 },
];

const handleAddToCart = (product: { id: string; name: string; price: number }) => {
trigger("cart:updated", {
item: {
...product,
quantity: 1,
},
action: "add",
});
};

return (

<div>
  {products.map((product) => (
    <div key={product.id}>
      <h3>{product.name}</h3>
      <p>\${product.price}</p>
      <button onClick={() => handleAddToCart(product)}>Add to Cart</button>
    </div>
  ))}
</div>
); }

// Cart sidebar component
function CartSidebar() {
const [cartItems, setCartItems] = useState<CartItem[]>([]);

useMonitorEvent<AppEvents>({
"cart:updated": (data) => {
setCartItems((prev) => {
if (data.action === "add") {
const existing = prev.find((item) => item.id === data.item.id);
if (existing) {
return prev.map((item) =>
item.id === data.item.id
? { ...item, quantity: item.quantity + 1 }
: item
);
}
return [...prev, data.item];
} else if (data.action === "remove") {
return prev.filter((item) => item.id !== data.item.id);
}
return prev;
});
},
});

const total = cartItems.reduce(
(sum, item) => sum + item.price \* item.quantity,
0
);

return (

<div>
<h2>Shopping Cart</h2>
{cartItems.length === 0 ? (
<p>Cart is empty</p>
) : (
<>
{cartItems.map((item) => (
<div key={item.id}>
{item.name} x{item.quantity} - \${(item.price \* item.quantity).toFixed(2)}
</div>
))}
<div>Total: \${total.toFixed(2)}</div>
</>
)}
</div>
);
}

// Persistence service
function CartPersistence() {
useMonitorEvent<AppEvents>({
"cart:updated": async (data) => {
// Save to localStorage
const currentCart = JSON.parse(
localStorage.getItem("cart") || "[]"
) as CartItem[];

      let updatedCart: CartItem[];
      if (data.action === "add") {
        const existing = currentCart.find((item) => item.id === data.item.id);
        if (existing) {
          updatedCart = currentCart.map((item) =>
            item.id === data.item.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          );
        } else {
          updatedCart = [...currentCart, data.item];
        }
      } else if (data.action === "remove") {
        updatedCart = currentCart.filter((item) => item.id !== data.item.id);
      } else {
        updatedCart = currentCart.map((item) =>
          item.id === data.item.id ? data.item : item
        );
      }

      localStorage.setItem("cart", JSON.stringify(updatedCart));
    },

});

return null;
}

// Notification service
function CartNotifications() {
const trigger = useTriggerEvent<AppEvents>();

useMonitorEvent<AppEvents>({
"cart:updated": (data) => {
if (data.action === "add") {
trigger("toast.show", {
message: \`\${data.item.name} added to cart!\`,
type: "success",
});
} else if (data.action === "remove") {
trigger("toast.show", {
message: \`\${data.item.name} removed from cart\`,
type: "info",
});
}
},
});

return null;
}`}
/>

<ExampleSection
  title="Multi-Step Workflow"
  description="Coordinate multi-step processes where each step triggers the next, creating a workflow chain. This demonstrates how listeners can trigger events that other listeners respond to."
  eventFlow={`Start → trigger("workflow:start") → Step 1 (monitors & triggers)
                                              → Step 2 (monitors & triggers)
                                              → Step 3 (monitors & triggers)
                                              → Completion Handler (monitors)
                                              → Logger (monitors all steps)`}
  demo={<MultiStepWorkflowDemo />}
  code={`"use client";

import {
  EventDriver,
  EventProvider,
  useMonitorEvent,
  useTriggerEvent,
} from "@protoworx/react-ripple-effect";
import { useState } from "react";

type AppEvents = {
"workflow:start": { orderId: string };
"workflow:step1-complete": { orderId: string; step1Data: any };
"workflow:step2-complete": { orderId: string; step2Data: any };
"workflow:step3-complete": { orderId: string; step3Data: any };
"workflow:complete": { orderId: string; result: any };
};

const client = new EventDriver();

export default function App() {
  return (
    <EventProvider client={client}>
      <WorkflowStarter />
      <Step1Processor />
      <Step2Processor />
      <Step3Processor />
      <WorkflowCompletionHandler />
    </EventProvider>
  );
}

// Start the workflow
function WorkflowStarter() {
const trigger = useTriggerEvent<AppEvents>();

const handleStart = () => {
trigger("workflow:start", { orderId: "order-123" });
};

return <button onClick={handleStart}>Start Order Processing</button>;
}

// Step 1: Validates order and triggers step 2
function Step1Processor() {
const trigger = useTriggerEvent<AppEvents>();

useMonitorEvent<AppEvents>({
"workflow:start": async (data) => {
// Process step 1
await validateOrder(data.orderId);

      // Trigger next step - listener triggers another event!
      trigger("workflow:step1-complete", {
        orderId: data.orderId,
        step1Data: { validated: true },
      });
    },

});

return <div>Step 1: Validate Order</div>;
}

// Step 2: Processes payment and triggers step 3
function Step2Processor() {
const trigger = useTriggerEvent<AppEvents>();

useMonitorEvent<AppEvents>({
"workflow:step1-complete": async (data) => {
// Process step 2
await processPayment(data.orderId);

      // Trigger next step - another listener triggering an event!
      trigger("workflow:step2-complete", {
        orderId: data.orderId,
        step2Data: { paymentProcessed: true },
      });
    },

});

return <div>Step 2: Process Payment</div>;
}

// Step 3: Ships order and triggers completion
function Step3Processor() {
const trigger = useTriggerEvent<AppEvents>();

useMonitorEvent<AppEvents>({
"workflow:step2-complete": async (data) => {
// Process step 3
await shipOrder(data.orderId);

      // Trigger completion
      trigger("workflow:step3-complete", {
        orderId: data.orderId,
        step3Data: { shipped: true },
      });
    },

});

return <div>Step 3: Ship Order</div>;
}

// Completion handler monitors the final step
function WorkflowCompletionHandler() {
const [completed, setCompleted] = useState<string[]>([]);

useMonitorEvent<AppEvents>({
"workflow:step3-complete": (data) => {
setCompleted((prev) => [...prev, data.orderId]);
},
});

return (

<div>
  <h3>Completed Orders</h3>
  {completed.map((id) => (
    <div key={id}>{id}</div>
  ))}
</div>
); }

// Helper functions (simulated)
async function validateOrder(orderId: string) {
await new Promise((resolve) => setTimeout(resolve, 1000));
}

async function processPayment(orderId: string) {
await new Promise((resolve) => setTimeout(resolve, 1200));
}

async function shipOrder(orderId: string) {
await new Promise((resolve) => setTimeout(resolve, 800));
}`}
/>

## Key Patterns

### 1. One-to-Many Communication

One trigger can notify multiple monitors, enabling decoupled updates across your app.

### 2. Service Separation

Separate concerns by having dedicated services (analytics, persistence, logging) monitor events.

### 3. Workflow Coordination

Use events to coordinate multi-step processes without tight coupling. Listeners can trigger events that other listeners respond to, creating a chain of workflow steps. Each step is decoupled and can be modified independently.

### 4. Cross-Component Updates

Update multiple UI components simultaneously when data changes.

## Related Examples

- [Basic Usage](/docs/examples/basic-usage) - Learn the fundamentals
- [TypeScript Examples](/docs/examples/typescript) - Type-safe event patterns
- [Debounce & Throttle](/docs/examples/debounce-throttle) - Performance optimization
- [Async Callbacks](/docs/examples/async-callbacks) - Async event handling
