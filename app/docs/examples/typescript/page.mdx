# TypeScript Support

Learn how to use TypeScript with `@protoworx/react-ripple-effect` for type-safe event handling.

## Overview

TypeScript support ensures that event names and their data types are checked at compile time, preventing runtime errors and improving developer experience.

## Defining Event Types

Create an `EventMap` type that maps event names to their data types:

```tsx
type AppEvents = {
  "user-logged-in": { userId: number; username: string };
  "toast.show": { message: string; type?: "info" | "error" | "success" };
  "cart-updated": { itemId: string; quantity: number };
  "search-performed": { query: string; results: number };
};
```

## Type-Safe Triggering

Pass the `EventMap` type to `useTriggerEvent` for type checking:

```tsx
"use client";

import { useTriggerEvent } from "@protoworx/react-ripple-effect";

type AppEvents = {
  "user-logged-in": { userId: number; username: string };
  "toast.show": { message: string; type?: "info" | "error" };
};

function LoginButton() {
  const trigger = useTriggerEvent<AppEvents>();

  const handleLogin = () => {
    // ✅ TypeScript knows the exact shape of data
    trigger("user-logged-in", { userId: 123, username: "alice" });
    
    // ✅ TypeScript knows optional properties
    trigger("toast.show", { message: "Welcome!", type: "success" });
    
    // ❌ TypeScript error: wrong event name
    // trigger("invalid-event", {});
    
    // ❌ TypeScript error: wrong data shape
    // trigger("user-logged-in", { wrong: "data" });
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

## Type-Safe Monitoring

Pass the `EventMap` type to `useMonitorEvent` for type checking:

```tsx
"use client";

import { useMonitorEvent } from "@protoworx/react-ripple-effect";

type AppEvents = {
  "user-logged-in": { userId: number; username: string };
  "toast.show": { message: string; type?: "info" | "error" };
};

function UserProfile() {
  useMonitorEvent<AppEvents>({
    "user-logged-in": (data) => {
      // ✅ TypeScript knows data is { userId: number; username: string }
      console.log(`User ${data.username} (ID: ${data.userId}) logged in`);
    },
    "toast.show": (data) => {
      // ✅ TypeScript knows data is { message: string; type?: "info" | "error" }
      console.log(`Toast: ${data.message}`, data.type);
    },
  });

  return <div>User Profile</div>;
}
```

## Complete Example

Here's a complete type-safe example:

```tsx
"use client";

import {
  EventDriver,
  EventProvider,
  useMonitorEvent,
  useTriggerEvent,
} from "@protoworx/react-ripple-effect";
import { useState } from "react";

// Define all events in your application
type AppEvents = {
  "user-logged-in": { userId: number; username: string };
  "toast.show": { message: string; type?: "info" | "error" | "success" };
  "cart-updated": { itemId: string; quantity: number };
};

const client = new EventDriver();

export default function App() {
  return (
    <EventProvider client={client}>
      <LoginForm />
      <ToastContainer />
      <CartDisplay />
    </EventProvider>
  );
}

function LoginForm() {
  const trigger = useTriggerEvent<AppEvents>();

  const handleLogin = () => {
    trigger("user-logged-in", {
      userId: 1,
      username: "alice",
    });
    trigger("toast.show", {
      message: "Welcome back!",
      type: "success",
    });
  };

  return <button onClick={handleLogin}>Login</button>;
}

function ToastContainer() {
  const [toasts, setToasts] = useState<Array<{ message: string; type?: string }>>([]);

  useMonitorEvent<AppEvents>({
    "toast.show": (data) => {
      // TypeScript ensures data has the correct shape
      setToasts((prev) => [...prev, data]);
      setTimeout(() => {
        setToasts((prev) => prev.slice(1));
      }, 3000);
    },
  });

  return (
    <div>
      {toasts.map((toast, i) => (
        <div key={i} className={`toast toast-${toast.type}`}>
          {toast.message}
        </div>
      ))}
    </div>
  );
}

function CartDisplay() {
  const [cartItems, setCartItems] = useState<Record<string, number>>({});

  useMonitorEvent<AppEvents>({
    "cart-updated": (data) => {
      // TypeScript ensures data has itemId and quantity
      setCartItems((prev) => ({
        ...prev,
        [data.itemId]: data.quantity,
      }));
    },
  });

  return (
    <div>
      <h3>Cart</h3>
      {Object.entries(cartItems).map(([itemId, quantity]) => (
        <div key={itemId}>
          Item {itemId}: {quantity}
        </div>
      ))}
    </div>
  );
}
```

## Benefits of TypeScript

- **Compile-time Safety**: Catch errors before runtime
- **IntelliSense**: Get autocomplete for event names and data shapes
- **Refactoring**: Rename events safely across your codebase
- **Documentation**: Event types serve as inline documentation

## Best Practices

1. **Centralize Event Types**: Define all events in a single file or module
2. **Use Descriptive Names**: Event names should clearly indicate their purpose
3. **Keep Types Simple**: Prefer simple data structures over complex nested types
4. **Export Types**: Export your `EventMap` type so it can be reused

## Related Examples

- [Basic Usage](/docs/examples/basic-usage) - Learn the fundamentals
- [Real-World Examples](/docs/examples/real-world) - See TypeScript in action

